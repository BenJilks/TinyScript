
/* Define block */
<dec-block> ::= (<import> | <variable-dec> | <function-dec> | <class>)*
<import> ::= import <file> (, <file>)*
<variable-dec> ::= declare <type> <name> (, <name>)*
<function-dec> ::= function <name> '(' <params> (, <params>)* ')' (< <type>) <block>
<class> ::= class <name> '{' (<variable-dec> | <method>)* '}'
<method> ::= method <name> '(' <params> (, <params>)* ')' (< <type>) <block>

/* Content block */
<statement> ::= <variable-dec> | <assign> | <function-call> | <ifstatement> | <whileloop> | <forloop> | <return>
<block> ::= <statement> | ('{' (<statement>)* '}')
<assign> ::= <variable> = <expression>
<function-call> ::= <variable>
<ifstatement> ::= if <condistion> <block>
<whileloop> ::= while <condistion> <block>
<forloop> ::= for <type> <name> = <expression> to <expression> <block>
<return> ::= return <expression>

/* Expression parser */
<bool-expression> ::= <bool-factor> (<andop> <bool-factor>)*
<bool-factor> ::= <identifier> | <bool> | <relation>
<relation> ::= <expression> (<relop> <expression>)*
<value-expression> ::= <term> (<addop> <term>)*
<term> ::= <factor> (<mulop> <factor>)*
<factor> ::= <variable> | <number> | (<expression>)

/* Variable parser */
<variable> ::= <variable-factor> (. <variable-factor>)*
<variable-factor> ::= <identifier> '(' <expression> (, <expression>)* ')')

RAM
This will be an array of chars,
The first <stack_size> chars will act as the stack
The next <frame_size> will store the local variables in a function
The final <ram_size> will act a the working RAM
<memory_size> ::= <stack_size> + <ram_size>

REGISTERS
pc ::= the program counter
sp ::= the stack pointer
fp ::= a pointer to the start of the current stack frame

/* Code-gen helper */

<variable-member> = 
	push <object-addr> + <member-addr>
	OR
	cpy sp <object-addr> + <member-addr> <member-size>
	inc sp <member-size>

<local-var> =
	fget <addr>

<number> = 
	push <number>

<term> = 
	push <number>
	add

<function call> = 
	inc fp <local scope size>
	push arg0
	push arg1
	cpy sp arg2
	inc sp <size of arg2>

<function parse> =
	dec sp <size of arg2>
	cpy fp + <arg2> sp
	fset arg1
	fset arg2

	...

	dec fp <local scope size>

<ifstatement> =
	push <condition>
	jumpifnot EndTag
	<block>
	EndTag:

<whilelook> = 
	StartTag:
	push <condition>
	jumpifnot EndTag
	<block>
	jump StartTag
	EndTag:

<forloop> = 
	push <start_value>
	set <counter>
	StartTag:
	push <end_value>
	get <counter>
	less
	jumpifnot EndTag
	<block>
	jump StartTag
	EndTag:

/* Bytecode */

STACK
push <value> - Push a value to the stack
set <addr> - Set a value at the address to the value at the top of the stack, then pop
get <addr> - Push the value at the address to the top of the stack
fset <addr> ::= set fp + <addr>
fget <addr> ::= get fp + <addr>

MEMORY
cpy <addr> <addr> <size> - Copy <size> amount of memory from one address to anouther
scpyto <addr> <size> ::= cpy sp <addr> <size>
scpyfrom <addr> <size> ::= cpy <addr> sp <size>
inc <addr> <value> - Increase the value at an address by <value> amount
dec <aadr> <value> - Decrease the value at an address by <value> amount
sinc <value> ::= inc sp <value>
sdec <value> ::= dec sp <value>

STACK FRAME
sfcpyto <offset> <size> - Copy data from the stack frame to the top of the stack (::= cpy sp <offset> + fp <size>)
sfcpyfrom <offset> <size> - Copy data from the top of the stack to the stack frame (::= cpy <offset> + fp sp <size>)
finc <value> ::= inc fp <value>
fdec <value> ::= dec fp <value>

MATHS - Pop the top two values of the stack, peform and operation and add the resualt
add = "+"
sub = "-"
mul = "*"
div = "/"

CONDITIONAL
eql   = "=="
neql  = "!="
more  = ">"
less  = "<"
emore = ">="
eless = "<="

PROGRAM FLOW
jump <addr> - Set 'pc' to <addr>
jumpifnot <addr> - Jumps to <addr> if the top stack value is false
call <function> - Calls a function
return - Returns from a function


push set get fset fget
cpy scpyto scpyfrom sfcpyto sfcpyfrom inc dec sinc sdec
add sub mul div
eql neql more less emore eless
jump jumpifnot call return
