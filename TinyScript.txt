
/* Define block */
<dec-block> ::= (<import> | <variable-dec> | <function-dec> | <class>)*
<import> ::= import <file> (, <file>)*
<variable-dec> ::= declare <type> <name> (, <name>)*
<function-dec> ::= func (<type>)? <name> '(' <params> (, <params>)* ')' <block>
<class> ::= class <name> '{' (<variable-dec> | <method>)* '}'
<method> ::= method <name> '(' <params> (, <params>)* ')' (< <type>) <block>

/* Content block */
<statement> ::= <variable-dec> | <assign> | <function-call> | <ifstatement> | <whileloop> | <forloop> | <return>
<block> ::= <statement> | ('{' (<statement>)* '}')
<assign> ::= <variable> = <expression>
<function-call> ::= <variable>
<ifstatement> ::= if <condistion> <block>
<whileloop> ::= while <condistion> <block>
<forloop> ::= for <type> <name> = <expression> to <expression> <block>
<return> ::= return <expression>

/* Expression parser */
<bool-expression> ::= <bool-factor> (<andop> <bool-factor>)*
<bool-factor> ::= <identifier> | <bool> | <relation>
<relation> ::= <expression> (<relop> <expression>)*
<value-expression> ::= <term> (<addop> <term>)*
<term> ::= <factor> (<mulop> <factor>)*
<factor> ::= <variable> | <number> | (<expression>)

/* Variable parser */
<variable> ::= <variable-factor> (. <variable-factor>)*
<variable-factor> ::= <identifier> '(' <expression> (, <expression>)* ')')

RAM
This will be an array of chars,
The first <stack_size> chars will act as the stack
The next <frame_size> will store the local variables in a function
The final <ram_size> will act a the working RAM
<memory_size> ::= <stack_size> + <ram_size>

REGISTERS
pc ::= the program counter
sp ::= the stack pointer
fp ::= a pointer to the start of the current stack frame

/* Code-gen helper */

<variable-member> = 
	push <object-addr> + <member-addr>
	OR
	cpy sp <object-addr> + <member-addr> <member-size>
	inc sp <member-size>

<local-var> =
	fget <addr>

<number> = 
	push <number>

<term> = 
	push <number>
	add

<function call> = 
	inc fp <local scope size>
	push arg0
	push arg1
	cpy sp arg2
	inc sp <size of arg2>

<function parse> =
	dec sp <size of arg2>
	cpy fp + <arg2> sp
	fset arg1
	fset arg2

	...

	dec fp <local scope size>

<ifstatement> =
	push <condition>
	jumpifnot EndTag
	<block>
	EndTag:

<whilelook> = 
	StartTag:
	push <condition>
	jumpifnot EndTag
	<block>
	jump StartTag
	EndTag:

<forloop> = 
	push <start_value>
	set <counter>
	StartTag:
	push <end_value>
	get <counter>
	less
	jumpifnot EndTag
	<block>
	jump StartTag
	EndTag:

/* Bytecode */

STACK
push <value> - Push a value to the stack
pushc <value> - Push a char type into the stack
set <addr> - Set a value at the address to the value at the top of the stack, then pop
get <addr> - Push the value at the address to the top of the stack
setc <addr> - Sets a char value (or size 1)
getc <addr> - Gets a char value
fset <addr> ::= set fp + <addr>
fget <addr> ::= get fp + <addr>
fsetc <addr> ::= setc fp + <addr>
fgetc <addr> ::= getc fp + <addr>

MEMORY
cpy <addr> <addr> <size> - Copy <size> amount of memory from one address to anouther
scpyto <addr> <size> ::= cpy sp <addr> <size>
scpyfrom <addr> <size> ::= cpy <addr> sp <size>
inc <addr> <value> - Increase the value at an address by <value> amount
dec <aadr> <value> - Decrease the value at an address by <value> amount
sinc <value> ::= inc sp <value>
sdec <value> ::= dec sp <value>

STACK FRAME
sfcpyto <offset> <size> - Copy data from the stack frame to the top of the stack (::= cpy sp <offset> + fp <size>)
sfcpyfrom <offset> <size> - Copy data from the top of the stack to the stack frame (::= cpy <offset> + fp sp <size>)
finc <value> ::= inc fp <value>
fdec <value> ::= dec fp <value>
cpyargs <size> ::= sdec <size>; sfcpyfrom 0 <size>

MATHS - Pop the top two values of the stack, peform and operation and add the resualt
add  = "+"
addf = add (float)
sub  = "-"
subf = sub (float)
mul  = "*"
mulf = mul (float)
div  = "/"
divf = div (float)

CONDITIONAL
eql    = "=="
eqlf   = eql (float)
neql   = "!="
neqlf  = neql (float)
more   = ">"
moref  = more (float)
less   = "<"
lessf  = less (float)
emore  = ">="
emoref = emore (float)
eless  = "<="
elessf = eless (float)

PROGRAM FLOW
jump <addr> - Set 'pc' to <addr>
jumpifnot <addr> - Jumps to <addr> if the top stack value is false
call <function> - Calls a function
return - Returns from a function


push pushc set get setc getc fset fget fsetc fgetc
cpy scpyto scpyfrom sfcpyto sfcpyfrom inc dec sinc sdec
sfcpyto sfcpyfrom finc fdec cpyargs
add addf sub subf mul mulf div divf
eql eqlf neql neqlf more moref less lessf emore emoref eless elessf
jump jumpifnot call return
